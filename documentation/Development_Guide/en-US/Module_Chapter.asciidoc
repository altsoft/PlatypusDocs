[[javascript-module]]
JavaScript module
-----------------

Module is a JavaScript file containing the constructor function and some specific resources.
Modules contain data model responsible for data access and <ModuleName>.model file contains
its data model definition.

Modules can be executed both under JVM in a client and server on Oracle Nashorn
javasceript engine or in a browser.

[[new-module-creation]]
New module creation
-------------------

To create a new module, perform the following actions:

* Select New in the parent directory context menu, or select the parent
directory and click New Filе in the main menu, or click New File on the
toolbar, or use a corresponding shortcut.
* Select Module type in the context menu, or select Choose file type
Platypus application elements Module on the wizard first step and click
Next.
* Enter the name of a new application element in the Name field and
click Finish to create it, or click Cancel to cancel.

[[javascript-code-editor]]
JavaScript code editor
----------------------

You can edit the module code in the JavaScript code editor. To open the
application element editor, double-click an application element in the
project tree.

To edit the JavaScript code:

* Open the Source tab of the module editor.
* Change text in the JavaScript code editor.
* Use the code completion for field names and functions of objects and
modules.
* Use automatic transition to declarations of variables, functions, and
to the functions of other modules; to do this, click a module ID or
function while holding down the Ctrl key.
* Use context menus and shortcuts to use built-in editor functions.
* Save the application element by clicking Save All on the Platypus
Application Designer toolbar or by using the Ctrl S keyboard shortcut.

___________________________________________________________________________________________
*Note*

Use the editor's context menu Format menu item to format the JavaScript
code automatically.
___________________________________________________________________________________________

If necessary, configure the code editor parameters; to do this:

* Select the following main menu items: Tools Options.
* In the Options properties dialog, select the Editor tab.

To configure auto completion modes, go to the Code Completion tab and
enable or disable corresponding options.

[[module-constructor]]
Module constructor
------------------

Using modules allows you to manage the complexity according to the
object-oriented programming principles.

Module is an equivalent of a class in other programming languages, such
as in Java or C++.

Every module contains a constructor function. This function is used for
module's instanses creation.

Constructor function can have a header, which is represented as a
comment in the JsDoc format and is located at the top of the module constructor
function definition.

Example of a module with a header:

[source,Javascript]
------------------------------- 
/**
 * Module description goes here
 *
 * @constructor
 * @rolesAllowed admin
 *
 */
function ModuleConstructor(p) {
  ...
}

function otherFunction() {
  ...
}
-------------------------------

If a JavaScript file contains exactly one top-level fucntion, this
fuction is considered as a module constructor, otherwise the module
constructor must be marked with the `@constructor` annotation.

In addition to the `@constructor` annotation, a header may contain the module
description, annotations for defining security constraints and other
JsDoc annotations.

Specify module instance methods:

[source,Javascript]
----------------------------------------------------------

function ModuleA() {
   
   this.somePublicMethod = fucntion(p) { //instance method
      ...
   }
}
----------------------------------------------------------

Module instance methods are available for the client code.

Add module scope methods and fields:

[source,Javascript]
----------------------------------------------------------

function ModuleB() {
   var a, b, c;//private `fields`

   this.somePublicMethod = function(p) { //instance method
      ...
   }

   function somePrivateMethod() { //scope function
      ...
   }
}
----------------------------------------------------------

Create or get a module instance by the following ways:

* Create an instance of the module with the help of the `new` keyword,
using a module constructor, for example:
+
[source,Javascript]
---------------------------- 
var moduleInstance = new ModuleA();
----------------------------
+
where `ModuleA` is a module constructor.
* Create an instance of the module with the help of the `new` keyword
using global object and its properties, for example:
+
[source,Javascript]
---------------------------------- 
var global = this;// Somewhere in global namespace
var moduleName = getPrincipalStartView();// Some impersonate technique
var moduleInstance = new global[moduleName]();
----------------------------------
+
where `moduleName` is the module constructor name string, for example, `"WebModule"`;
* Create a proxy/stub for the server module, to use RPC on client or Local procudure call (LPC) on apllication server:
+
[source,Javascript]
---------------------------------------- 
var moduleStub = new P.ServerModule("Processor");
----------------------------------------
+
where `Processor` is the module constructor name string. The server module
should be marked with the `@public` annotation to enable access via the network.
Server modules, with is used only within application server don't need the `@public` annotation
to be used with LPC.

To call the module's instance method, use the following structure, for
example:

[source,Javascript]
------------------------------------------

moduleInstance.getResult(10, function(aResult){
    var result = aResult;
});
------------------------------------------

[[dependencies-resolving]]
Dependencies resolving
----------------------

When executing the code on a application server or on a client, all application elements,
on which initial application element depends, are loaded during the process of automatic dependencies
resolution.

Automatic dependencies resolving works as follows:

* The source code is analyzed and expressions of the following types are
searched for the following expressions:
+
`new ModuleName()`
+
`new ServerModule("")`
+
`new Report("")`
+
`new ServerReport("")`
+
where ModuleName is the name of the module.
* Application elements with the specified names are loaded or server
proxies for server modules/reports are generated.
* The process continues recursevly for the loaded modules, except for
the server proxies.

If it is not necessary or not possible to resolve the dependency
automatically, for example, if you want to determine the called module
in a dynamic manner, you can use the manual dependencies resolving with
`P.require` function.

Use `P.require([param], callback)` global function, where param is the module
constructor name, or the relative path to the JavaScript file in the
application, or an array of these elements, callback is a function,
which will be called when all the specified modules are downloaded and
executed. Both synchronous and asynchronous modes of P.require function calls are supported.
If callback is omitted, than synchronous version of function is used.

NOTE: Don't use manual dependencies resolving against a server modules. It
will lead to an attempt to download the module body on the client.

Example of using manual dependencies resolving is as follows:

[source,Javascript]
------------------------------------------------

var moduleName1 = "Module1",
    moduleName2 = "Module2";
P.require([moduleName1, moduleName2], function() {
  var m1 = new Module(moduleName1);
  m1.bar();
  var m2 = new Module(moduleName2);
  m2.foo();
});
------------------------------------------------

The following example shows how to use the `P.require` function for
loading the module by its constructor name as well as the plain
JavaScript file by specifing its path:

[source,Javascript]
----------------------------------------------------
P.require(["Module1",
 "localLib.js"], function() {
  
  //Platypus module
  var m1 = new Module("Module1");
  m1.bar();
  
  // Constructor LibObject is defined in localLib.js
  var o1 = new LibObject();
});
----------------------------------------------------

Relative paths are counted off from the `app` directory of the Platypus
application project. If the JavaScript file path matches the Platypus module
identifier name, the Platypus module will be preferred.

The `P.require` function also has a synchronous variant, which can be used
in the server code. In this case, if you don't need to maintain
compatibility with the client's code, the second parameter is optional:

[source,Javascript]
-------------------------------------- 
P.require("localLib.js");
// LibObject is defined in localLib.js
var obj = new LibObject();
--------------------------------------

The `P.require` function supports relative paths for both synchronous and synchronous variants:
[source,Javascript]
-------------------------------------- 
P.require("./sublibs/sublib-a.js");
// SubLibObjectA is defined in sublib-a.js
var obja = new SubLibObjectA();
P.require("./sublibs/sublib-b.js", function(){
    // SubLibObjectB is defined in sublib-b.js
    var objb = new SubLibObjectB();
});
--------------------------------------

You should pay attention to the combination of automatic and manual
dependencies resolution. For example, in the following snippet it is not
necessary to call the `P.require` function:

[source,Javascript]
------------------------------------------------
var moduleName1 = "SampleModule1",
    moduleName2 = "SampleModule2";
P.require([moduleName1, moduleName2], function() {
  var m1 = new SampleModule1();
  m1.bar();
  var m2 = new SampleModule2();
  m2.foo();
});
------------------------------------------------

This code leads to the automatic dependencies resolution regarding to
the SampleModule1 и SampleModule2, as calls of their constructors are
present in the code in explicit form.

On the other hand, creating modules in the `var m = new SampleModule1()`
form is natural and it is preferred in most cases.
In order to avoid automatic resolving of dependencies, explicitly specify module constructor names in the form of
string literals the `P.require` function parameter:

[source,Javascript]
--------------------------------------------------------
P.require(["SampleModule1", "SampleModule2"], function() {
  var m1 = new SampleModule1();
  m1.bar();
  var m2 = new SampleModule2();
  m2.foo();
});
--------------------------------------------------------

This method of calling the `P.require` function excludes these explicitly
specified constructor names in the first parameter from the automatic
dependencies resolution. So, SampleModule1 and SampleModule2 will be
loaded only when calling the `P.require`, rather than before starting the
application.

[[security]]
Security
--------

The executable module code is a resource, access to which can be
restricted on the basis of the roles. When a user, who has no rights to
execute some code, tries to call it, a security exception is thrown.

In order to restrict access to the entire module code, add the
`@rolesAllowed`... annotation to the module header. Specify roles,
allowed to access the module code execution, in the `@rolesAllowed`
annotation, dividing them by spaces. If the annotation is omitted,
access to the module is granted to all users.

You can restrict access to the module code on the level of an individual
function. To do this, add the `@rolesAllowed` annotation to the
function's JsDoc. The restrictions on the function level have a higher
priority than the module level restrictions. For example, only a user
with the `role2` role from the following example will have access to the
`f2`:

[source,Javascript]
---------------------------- 
/**
 * @constructor
 * @rolesAllowed role1 role2
 *
 */
function ModuleC {

   var self = this;

   /**
    * @rolesAllowed role2
    */
   this.f2 = function() {
      //...
   }
}
----------------------------

Use `principal` property to get access to the information about the
current user in the executable code. The `principal` property is
read-only. The object of information about the user contains the `name`
property, i.e. the name of the current user, and the `hasRole()`method,
which allows you to check if this user has any role:

[source,Javascript]
----------------------------------------------------

P.Logger.info('Current user: ' + P.principal.name);

if (P.principal.hasRole('Manager')) {
  // Some operations allowed only to managers ...
}
----------------------------------------------------

Use `P.logout(onLoggedOut, onError)` function, where `onLoggedOut` is a function, which will be called
after the session is terminated and onError is a function, which will be called if an error occur.
Open forms will be closed and the user will see the login and password entering form.

[[resources-loading]]
Resources loading
-----------------

The platfrom runtime enables loading of resources in the form of binary
data and text. Resources may be loaded using their applicaion paths or
URLs. Applicaion paths are counted off from the `app` root directory of
the application project. Use the Resource object methods for resource loading.

To download a resource, use the `Resource.load(path, callback)` method, where
`path` is a application path or URL, `callback(obj)` is a function, which
will be called after the resource is loaded, `obj` is an array of bytes
of the downloaded resource for the server code and Platypus Client or an
object of the ArrayBuffer type for the HTML5 browser in the case of binary data
and string in the case of text data:

[source,Javascript]
---------------------------------------------

//Loads binary resource
P.Resource.load("res/pict.bin", function(obj) {
  ...
})
---------------------------------------------

[source,Javascript]
---------------------------------------------

//Loads text resource
P.Resource.load("res/list.txt", function(obj) {
  ...
})
---------------------------------------------

You can use a synchronous version of this method with a single parameter
in the server code or in the code, which is executed in the J2SE Client.
In this case, the method itself will return an array of bytes of
the downloaded resource:

[source,Javascript]
---------------------------------------- 
//Loads binary resource synchronously
var obj = P.Resource.load("res/pict.bin");
...
----------------------------------------

To get the absolute path to the application directory, use the
`Resource.applicationPath` read-only property:

[source,Javascript]
-------------------------------------- 
//Reads the application's path
P.Logger.info(Resource.applicationPath);
--------------------------------------

[[data-model]]
Data model
----------

Data model is a module's persistence manager. It provides access to the
data obtained from a relational database or any other data source. Data
model allows you to perform the following tasks:

* Fetch data from the data source(s) to the entities data arrays.
* Automatically requery data, according to the inter-entities
links.
* Save changes made to the entities data (insert, update and delete).
* Entities data change events handling with JavaScript.

Data model consists of entities and links and is configured using the
visual editor.

image:images/dataModel.png[Data model structure]

Data is stored in the form of JavaScript objects within an etnity's
data array.

Entities are created using a module implements special datasouce
interface methods or a query application element.
NOTE: Table entity is a special query entity, which selects all data from
the table. It is created automatically by runtime. A table entity can be
used only in two-tier configurations with direct connection to a database.

Each entity can have parameters and contains a data array with predefined
fields according to the data schema defined by the module or query, on
the basis of which the entity is created.

In general, a data array comprised of objects, each of which corresponds
to a tuple in the query results.

There is a cursor for each enitity. The cursor can point to some element in
the data array and determines the `current` item of this entity. Also the
cursor can point to null. The entity cursor value can affect to the
linked entities data.

Entity fields and parameters may be connected by links. The following
link types are used in a data model:

* Query link connects `source` field of one entity with another entity parameter as `target` field.
* Reference link defined by ORM on the basis of foreign keys derived from database/script datasource structure.

Query link requeries the target entity's data array according to the
parameter value change. The new parameter value is determined according
to the source point of the link. Both entitiy's cursor property's value or a
parameter value can be used. When the value at the link source changes,
new data is requested from the database or application server and reoladed in the target
entity data array.

Reference link is defined by a database table/script datasource structure foreign keys.
This kind of link is created automatically, if a entitiy's schema contains fields included
to such foreign key. This type of link does not affect the content of
the data arrays and is used to generate inter-element connections between
element of entities' data arrays. This is done via new properties, wich are created
while data fetching. The link of this type is visually shown as a dashed
line on the data model diagram.

___________________________________________________________________________________________________________________________________________________________________________________________________
*Note*

To get inter-instance connections work, primary and foreign keys are
required. Such keys may come from database structure definitions or from
schema definitions in a JavaScript datasource module.
___________________________________________________________________________________________________________________________________________________________________________________________________

image:images/dataModelLinks.png[Query and filtration types links]

The figure shows an example of operation of query links for
the three entities in the data model. In the `Persons` entity, a cursor
is pointing to a string corresponding to a person named `Mike`.

When initializing a module, data corresponding to the input parameter
values is loaded into the model by default, then every change of input
parameters leads to a cascade update of all datasets, which are directly
or inderectly associated with the modified parameter.

For any entity you can determine any number of incoming and outgoing
links of both types. When building connections you should consider the
following restrictions:

* Links must not create circular references.
* Linked fields and parameters of the source and the target entities must
match by thiers type: the types of connected fields and parameters must
allow the mutual conversion of values. For example, it is possible to
connect field if there's a number specified for the connection on the
source, and a string specified the connection on the target, it is quite
possible, since there is a possibility of an unambiguous conversion of a
number to a string, but not vice versa.

Added, deleted and changed datasets of these entities objects are saved
to the database or sent to the application server for subsequent saving
when calling the save function of the data model object.

The data model object is represented in the module constructor by the
result of call to `P.loadModel(name)` function, where name is name of already loaded module.

Create a variable for the data model object and assign result of P.loadModel() to it. 
In the following code snippets we will use such variable:

[source,Javascript]
-------------------------- 
function ModuleD() {
   var model = P.loadModel(this.constructor.name);
   //...
}
--------------------------

* Set the data model parameters to update the data of the linked
entities.
* Get access to data for data processing, analysis, and so on.
* Use inter-instances connections to process the data in ORM manner.
* Use the cursor as "current" data array element pointer.
* Specify entity event handler functions and write their JavaScript
code.
* Alter, remove or add objects in the entity's data array and allow the data model to
save the changes.
* Read entity schema (fields metadata) for special needs.

To force refetch of all data model entities' data arrays, call the requery function
of the `model` object:

[source,Javascript]
----------------------------------- 
model.requery(onSuccess, onFailure)
-----------------------------------

where `onSuccess` is the handler function for refresh data on success
event (optional), `onFailure` is the handler function for refresh data
on failure event (optional).

[[data-model-editor]]
Data model editor
~~~~~~~~~~~~~~~~~

Data model is configured using the visual editor.

For navigating to a data model elements, it is convenient to use a data
model inspector panel. In the data model inspector, entity and model
parameters are presented in the form of a tree structure. You can select
an entity or a connection both in the visual editor and in the data
model inspector. Mutual positioning of the model data inspector and its
diagram is possible.

To add a table entity to the data model, perform the following steps:

* Select the Datamodel tab of the module's editor.
* Select the Add query / Add table Add table menu item on the editor
toolbar, or use the Ctrl Shift Insert shortcut.
* Select the table from the list in the table selection dialog, if
necessary select a schema from the drop-down Schema list; the Default
button sets the default schema for the application; use the search
option by clicking Find, if necessary.
* Click OK add the table or click Cancel to cancel.
* If necessary, move the table on the model diagram to the right place.
* Save the application element by clicking Save All on the main toolbar
or by using the Ctrl Shift S keyboard shortcut.

To add an entity based on an existing query to the data model, perform
the following actions:

* Select Add query / Add table Add query on the editor toolbar.
* Select an application element of the Query type in the dialog.
* Click OK to add the query or click Cancel to cancel.
* If necessary, move the query on the visual editor diagram to the right
place.
* Save the application element by clicking Save All on the main toolbar
or by using the Ctrl Shift S keyboard shortcut.

_____________________________________________________________________________________________________________________________________________________________________________________
*Note*

Drag an existing query or a module from the application elements tree on
the project panel to the visual editor diagram of the data model to
include it into the editable data model.
_____________________________________________________________________________________________________________________________________________________________________________________

An entity object and its data is available to module's JavaScript
code. When you add a new entity, its name will be specified by default,
according to the query, or module consturctor name or a table name in
the database. To change the name of the entity, perform the following
steps:

* Go to the Datamodel tab.
* Select the corresponding entity on the data model diagram or in the
data model inspector.
* In the Properties editing window specify the name value in the name
field. Entity name is case-sensitive and must meet the requirements for
the JavaScript identifiers.
* Save the application element by clicking Save All on the main toolbar
or by using the Ctrl Shift S keyboard shortcut.
______________________________________________________________________________________________________________________________________________
*Note*

If the Properties panel is not displayed, enable this panel. To do this,
select Window Properties in the Platypus Application Designer main menu.
_________________________________________________________________________________________________________________________________________________

To delete an entity from the data model, perform the following actions:

* Select an entity in the data model inspector or on the diagram.
* Click Delete on the editor toolbar.
* Save the application element by clicking Save All on the main toolbar
or by using the Ctrl Shift S keyboard shortcut.

To add a query link between two entites:

* Move the field or parameter to the parameter of an entity, with which you want to
make dependent on the first entity. The connection will be displayed as a line with
an arrow between parameters or field/parameter of theese two entities.
* Save the application element by clicking Save All on the main toolbar
or by using the Ctrl Shift S keyboard shortcut.

_______________________________________________________________________________________________________________________________________________
*Note*

Query link type in the visual editor is highlighted by purple. Reference
link is highlighted by black with dashed style. The link target field is shown by an
arrow.
_______________________________________________________________________________________________________________________________________________

To delete a link, perform the following actions:

* Select the link to remove by mouse click.
* Click Delete or use the Delete key.
* Save the application element by clicking Save All on the main toolbar
or by using the Ctrl Shift S keyboard shortcut.

To edit a reference link properties, perform the following actions:

* Select a dashed link by mouse click.
* Select Scalar and collection properties menu item from the foreign key
link context menu.
* In the dialog specify Scalar property name and Collection property
name fields.
* Save the application element by clicking Save All on the main toolbar
or by using the Ctrl Shift S keyboard shortcut.

To zoom-in or zoom-out the data model visual presentation:

* Click Zoom In to scale up the data model presentation in the editor;
click Zoom out to scale it down.

To use the search function on the data model diagram:

* Click Find to open the search dialog in the data model editor.
* Enter the search line, select fields to be used for searching:
Datasets, Fields, Params, and also check the necessary options: use the
Whole words option to search for the whole words. Use the Match case
option to perform the case-sensitive search.
* Click Next and Previous to go to the next or previous search result.
* Click Close to close the search dialog.

[[entities]]
Entities
~~~~~~~~

Data model entities are available as the data model object's properties:
`model.entity1`, where `entity1` is the script presentation of an entity.

Entities may have its own parameters and can be updated independently
from the other model entities.

To access entity parameters, use the `params` entity property:

[source,Javascript]
-------------------------- 
var entityParams = model.entity1.params;
--------------------------

where `entity1` is an object of the corresponding entity.

To access the specific parameters, use properties of the `model.entity1.params`
object with names, which match the entity parameter names:

[source,Javascript]
-------------------------------- 
var entityParam = model.entity1.params.param1;
--------------------------------

where `entity1` is an entity object,`param1` is the property of the corresponding parameter.

To set the parameter value, assign a new value to it:

[source,Javascript]
-------------------------- 
model.entity1.params.param1 = newValue;
--------------------------

where `newValue` is a new value of the parameter.

Setting a new value for a entity parameter doesn't result in automatic
update of the data array.

To update entity data and related entities, use the execute function.
New data will be loaded only if the entity parameter values were
changed:

[source,Javascript]
------------------------------- 
entity1.execute(onSuccess, onFailure);
-------------------------------

where `entity1` is an entity object, `onSuccess` is the handler function for 
success event (optional) and `onFailure` is the handler function failure event (optional).

To force the update of entity data and related entities, use the requery
function:

[source,Javascript]
------------------------------- 
model.entity1.requery(onSuccess, onFailure);
-------------------------------

where `entity1` is an entity object, `onSuccess` is the handler function for
success event (optional), `onFailure` is the handler function failure event (optional).
Callback functions are called when the database request is executed and its results
come to the client over the network.

Handler of the `onRequeried` entity event will be called in any case,
regardless of the method of calling the `requery` function.

______________________________________________________________________________________________________________________________________________________________________________________________________________________________
*Note*

Update of entity data does not cancel the data changes made in the
entity dataset earlier, so after saving the model these changes will be
applied to the database. Data changes are reset only after saving the
entire model or explicit call to `revert` method.
______________________________________________________________________________________________________________________________________________________________________________________________________________________________

To access to the entity's data, refer to the entity data arrayt as a regular
JavaScript array:

[source,Javascript]
------------------- 
var item = model.entity1[i];
-------------------

where `entity1` is an entity, `i` is an index of the array element within the
`0...length - 1` range.

The following example shows the process of enumerating document elements in
the `documents` entity's data array:

[source,Javascript]
--------------------------------------------

var documents = model.documents;

// Logs all documents names
for (var i = 0; i < documents.length; i++) {
  P.Logger.info(documents[i].name);
}
--------------------------------------------

If an reference link is established between two entities, you can get
access to the data of the connected entity by using data instance
property having the name configured earlier in propertoes of a link ion the datamodel designer.
This properties are generated during data fetch by Platypus.js ORM.

[source,Javascript]
-------------------------- 
var propValue = model.entity1[i].referencedObject.someData
--------------------------

where `entity1` is the name of an entity, which contains the external key
reference, `i` is an index of the array element within the `0...length - 1`
range, entityName2 is an entity containing the field, which is
referenced by the external key, `referencedObject` is a property of reference link
configured as `scalar` and `someData` is some data field of referenced object
If the entity contains a field, which is referenced by the external key,
the property contains an array of the connected entity objects:

[source,Javascript]
-------------------------- 
var referees = model.referencedEntity[i].referees;
P.Logger.info("referees.length: " + referees.length);
--------------------------

where `referencedEntity` is an entity, which contains the external key reference,
`i` is an index of the array element within the `0...length - 1`, range
referees is a name of collection property name configured earlier in datamodel designer in reference link properties dialog.

Change for a foregn key link scalar and collection properties if
required via reference link properties dialog in datamodel designer.

[[cursor-api]]
Cursor API
~~~~~~~~~~

To get access to the entity's "current" data array element use
the `model.entity1.cursor` property, for example:

[source,Javascript]
-------------------------------- 
var currentValue = model.entity1.cursor.price;
--------------------------------

where `entity1` is a corresponding entity, `price` is a property of interest.

The cursor points to some object, or it can be null.

After loading data array the cursor point on the first
entity's data array element.

[[saving-data]]
Saving data
~~~~~~~~~~~

Data model provides automatic tracking of data changes. Data
changes can be saved only as a part of entire model.

To edit, insert, or delete data, perform the following actions:

* Edit, insert, or delete an object from the entity data.
* Call the save method of the model.

To obtain access to the entity arbitrary objects, use the syntax of
referring to an array element:

[source,Javascript]
------------- 
model.entity1[i].propName = 56;
-------------

where `entity1` is an entity, entityName[i].propName is an object property
with the specified index in the entity data and `56` is an expression for the new value.

To change the appropriate property of the entity's cursor, use the
following way:

[source,Javascript]
---------- 
model.entity1.cursor.propName = 56;
----------

where `entity1` is an entity, `propName` is a property in the current cursor position in the entity
data array, `56` is an expression for the new value.

To save changes the data model changes, use its save method:

[source,Javascript]
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
model.save(onSuccess, onFailure);
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
where onSuccess is the handler function for an event of successfull saving of data (optional)
and onFailure is the handler function for a save data on failure event (optional).

To insert a new object to a data array and save it to datasource:

* Add a new object to entity data array by standard JavaScript array methods (push, unshift, splice).
* Call the save method of the data model.

If necessary, pass the JavaScript object, the property names of which
match the names of properties in the entity objects, as a parameter to
the function. Their values will be set as values of the new object
properties:

[source,Javascript]
-------------- 
model.entity1.push( {
  propName: 'disks',
  price: 89});
--------------

When using the push/unshift/splice function,
the cursor will point to a new object.

After inserting, the new object will have the following properties:

* An identifying property gets the generated value, if a value was not
explicitly assigned to this property when inserting.
* Properties belonging to the "key-value" get the transferred values.
* Other properties will be set to `null`.

Example of code for inserting a new object into the `documents` entity:

[source,Javascript]
---------------------------------------------------------

model.documens.push({id: 101, name: 'New document name'});
model.save(function(){});
---------------------------------------------------------

Use `remove` function and pass the object to be deleted or pass an array of objects to be deleted
as the parameter to avoid unnecessary iterations:

[source,Javascript]
------------------- 
model.entity1.remove(toBeDeleted);
model.entity1.remove([toBeDeleted1, toBeDeleted2, toBeDeleted3]);
-------------------

where `toBeDeleted` is the one of the data array elements.

Use the splice function to delete an object from the entity data by
passing an index and a number of elements to be deleted as arguments:

[source,Javascript]
------------------ 
model.entity1.splice(index, length);
------------------

where `entity1` is an entity, `index` is an index of the entity data array
element. `index` can take on a value within the `0...length-1` range and 
`length` is a number of elements to be deleted.

Example of deleting the current object from the `documents` entity and
from the database:

[source,Javascript]
----------------------------- 
// Removes first element
model.documents.splice(0, 1);
model.save(function(){});
-----------------------------

To remove all objects from the entity data, use the deleteAll entity
function:

[source,Javascript]
------------------- 
model.documents.splice(0, model.documents.length);
-------------------

Example of deleting all objects from the `documents` entity and from the
database:

[source,Javascript]
---------------------------- 
// Removes all elements
model.documents.splice(0, model.documents.length);
model.save(function(){});
----------------------------

Calling `save` function results in saving changes and commiting the
transaction.

Calling save function may lead to an exception, for example, if saved
data are inconsistent with the database schema. In this case data are
not saved to the database. To handle this exception, use failure callback:

[source,Javascript]
---------------------------------------- 
  model.save(function(){}, function(){
      model.revert();
      P.Logger.severe('Data are not saved, due to an error: ' + e);
  });
----------------------------------------

After handling the error, you can try to correct the cause of the
problem and re-call the save function.

Use model's `revert` method to revert model data changes. After this
method call, no data changes are avaliable for `save()` method, but the
model still attempts to commit. Calling `save()` on unchanged model
nevertheless leads to a commit even transaction will be empty.

[[find-api]]
Find API
~~~~~~~~~~

Find operations can be performed after the data model loads its
entities' data.

Search is performed in the model and doesn't send new requests to the
database neither changes the data.

To find an object by its primary key, use the findByKey entity method by
passing a key value to it:

[source,Javascript]
----------------------------- 
var item = model.entity1.findByKey(aKey);
-----------------------------

where `entity1` is an entity, `aKey` is an expression for the search key.

If nothing is found, the findByKey function returns the `null` value.

Example of code for searching for a document by its identifier and
displaying its name in the log:

[source,Javascript]
----------------------------------------------------

var documentId = 101;
var document = model.documents.findByKey(documentId);
if (document) {
  P.Logger.info('Document name is ' + document.name);
}
----------------------------------------------------

To perform search by arbitrary properties, use the find
entity's function. Pass the "key-value" pairs corresponding to the
property and search value as a JavaScript object to the find function. The search
is performed by checking the equality of the entity object property
values and values to search for.

[source,Javascript]
------------------------ 
var items = model.entity1.find({
  prop1: propValue1,
  prop2: propValue2//,
  //...
  //propN: propValueN
});
------------------------

where `entity1` is an entity, `prop1` and `prop2` are an entity properties`
and `propValue1` and `propValue2` are search keys values

___________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
*Note*

findByKey and find functions search for objects using prepared hash
table by corresponding properties and don't enumerate the entity's data array each time.
Therefore, it is recommended to logically separate the code for
searching and changing data, as after any change of data prepared hashes
are marked as obsolete, and are rebuilded when you attempt to perform
the search next time.
___________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

This code snippet illustrates search documents by their names and by the
set flag:

[source,Javascript]
--------------------------------------------

var documentName = 'Document 1';
var isChecked = true;
var documents = model.documents;
var foundDocuments = documents.find({
  name: documentName,
  checked: isChecked
});
foundDocuments.forEach(function(aFoundDocument){
  P.Logger.info(foundDocument.desc);
});
--------------------------------------------

[[sort-api]]
Sort API
~~~~~~~~

To sort entities' data arrays use standard JavaScript array `sort` function.

[[entity-events]]
Entity events
~~~~~~~~~~~~~

To implement some logic to react to the data events specify entity
events handlers functions. To create these handler functions assign
functions to entities' properties.

Entity data events list is given in the table below:

[cols="<,<,<",options="header",]
|=======================================================================
|Event |Event type |Description
|`onRequeried` |`EntityEvent` |Is called after re-requesting the entitiy's data
array.

|`onDeleted` |`DeleteEvent` |Is called after removing an object from the
entitiy's data array.

|`onInserted` |`InsertEvent` |Is called after inserting a new object
into the entitiy's data array.

|`onScrolled` |`ChangeEvent` |Is called after changing the cursor
in the entity's data array
|=======================================================================

`EntityEvent` is a generic entity object and contains the following
property:

[cols="<,<",options="header",]
|==============================
|Property |Description
|`source` |Event source object.
|==============================

Other entity events contain `source` property as in `EntityEvent`, as
well as their own specific properties.

`ChangeEvent` object specific propetries are listed in the following
table:

[cols="<,<",options="header",]
|======================================
|Property |Description
|`propertyName` |Changed property name.
|`oldValue` |The value before change.
|`newValue` |The value after change.
|======================================

`DeleteEvent` object specific propetries are listed in the following
table:

[cols="<,<",options="header",]
|==============================
|Property |Description
|`deleted` |The deleted objects.
|==============================

`InsertEvent` object specific propetries are listed in the following
table:

[cols="<,<",options="header",]
|================================
|Property |Description
|`inserted` |The inserted objects.
|================================

[[data-schema]]
Data schema
~~~~~~~~~~~

JavaScript code has access to an entity's fields metadata. It is
possible to read types, names, descriptions of entity properties and
parameters, and etc.

To read an entity's schema, use its `schema` property:

[source,Javascript]
----------------------------------- 
var entityMetadata = model.entity1.schema;
-----------------------------------

where `entity1` is an entity, which schema you are interested in.

To get access to the an entitiy's property metadata:

[source,Javascript]
---------------------------------- 
var propMetadata = model.entity1.schema.prop1;
----------------------------------

where `entity1` is an entity, `prop1` is the name of the corresponding property.

Example of code, which checks if the `id` property of the documents
entity is an object's key property.

[source,Javascript]
------------------------------------------------

if (model.documents.schema.id.pk) {
  P.Logger.info('id is key attribute of decuments entity.');
}
------------------------------------------------

The schema composed of the following properties:

[cols="<,<,<",options="header",]
|=======================================================================
|Property |Type |Description
|`pk` |Boolean |`true`, if the property is an ID key

|`name` |String |Property name

|`description` |String |Property description

|`readonly` |Boolean |`true`, if the property is read-only

|`size` |Number |Size of the property value

|`nullable` |Boolean |`true`, if the property can take on the `NULL`
value
|=======================================================================

To get the number of properties in the entity, use the `length` property
in the entity schema object:

[source,Javascript]
-------------------- 
model.entity.schema.length
--------------------

NOTE: If some field will have name as `length`, than its name will have a priority
and it will be impossible to determine length of .schema as in above example.

You can read the property's metadata by index as an array element:

[source,Javascript]
--------------- 
model.entity1.schema[i]
---------------

where `entity1` is an entity, and `i` is within the range from `0` to `entityMetadata.length - 1`.

Below you can find an example of output all properties of the documents
entity into the log:

[source,Javascript]
---------------------------------------------------------

for (var i = 0; i < model.documents.schema.length; i++) {
  P.Logger.info(documents.md[i]);
}
---------------------------------------------------------

To read the entity parameter metadata, use the `schema` property of the
`params` object of an entity:

[source,Javascript]
------------------------------------------

var paramsMetadata = model.entity1.params.schema;
------------------------------------------

You can read metadata composed of the following for the parameter:

[cols="<,<,<",options="header",]
|=======================================================================
|Property |Type |Description
|`modified` |Boolean |`true`, if the parameter was changed and `false`
otherwise

|`pk` |Boolean |`true`, if the parameter is a primary key and `false`
otherwise

|`name` |String |Name of the parameter

|`description` |String |Description of the parameter

|`readonly` |Boolean |`true`, if the parameter is read-only and `false`
otherwise

|`size` |Number |Size of the property value

|`nullable` |Boolean |`true`, if the parameter is not mandatory and
`false` otherwise
|=======================================================================

To get the number of the entity parameters:

[source,Javascript]
--------------------------- 
model.entity1.params.schema.length
---------------------------

where `entity1` is an entity.

NOTE: If some parameter will have name as `length`, than its name will have a priority
and it will be impossible to determine length of .schema as in above example.

[[dynamic-entities]]
Dynamic entities
~~~~~~~~~~~~~~~~

Use model's loadEntity(queryName) method, where queryName is the name of
the query to dynamically create an entity in the data model. The
generated entity can be used to read, insert or modify objects:

[source,Javascript]
---------------------------------------------------

var docEntity = model.loadEntity("Documents");
docEntity.requery(function(){}, function(){});

//Print all documents names
docEntity.forEach(function(doc) {
  P.Logger.info(doc.NAME);
});

//Change first document's name
docEntity[0] && docEntity[0].NAME = "New document";
model.save(function(){}, function(){});
---------------------------------------------------

Use model's createEntity(sqlText, datasourceName) method, where sqlText is arbitrary sql text
and is datasourceName the name of datasource accessible in your current environment
The generated entity can be used to read, insert or modify objects:

[source,Javascript]
---------------------------------------------------

var docEntity = model.createEntity("select * from tr_documents", "testdb");
docEntity.requery(function(){}, function(){});

//Print all documents names
docEntity.forEach(function(doc) {
  P.Logger.info(doc.NAME);
});

//Change first document's name
docEntity[0] && docEntity[0].NAME = "New document";
model.save(function(){}, function(){});
---------------------------------------------------

Use executeUpdate entity method to execute the SQL code, which contains
the `INSERT`, `UPDATE`, `DELETE` or DDL commands:

[source,Javascript]
----------------------------------------------------------------------------

var e = model.createEntity("DELETE * FROM Document d WHERE d.DOC_TYPE = 1");
e.executeUpdate(function(){}, function(){});
----------------------------------------------------------------------------

NOTE: createEntity method may be used only is two-tier environment. E.g. in Java EE
server, J2SE client or in Platypus TSA server.

[[executing-arbitary-sql]]
Executing arbitary SQL
~~~~~~~~~~~~~~~~~~~~~~

In addition to using entities based on a query, data model allows to
execute arbitrary SQL code. Using entities based on a query instance
have a number of advantages, such as security management or ability to
work with the client code. However, if necessary, you can execute
arbitrary SQL.

SQL execution is available on a server or on a desktop client wich has a
direct connection to a database.

Use executeSql(sqlClause, datasourceName, onSuccess, onFailure) model's method to execute the SQL code, which
contains the `INSERT`, `UPDATE`, `DELETE` commands, where `sqlClause` is the query text:

[source,Javascript]
---------------------------------------- 
model.executeSql("DROP TABLE Document", "testdb", function(){}, function(){});
----------------------------------------

[[data-source-module]]
Data source module
------------------

A module can be used as a data source in other modules' data models just
like a query.

To create a data source module implement the following instance
properties and methods:

* `schema` property to represent the data source metadata information.
The schema information is repesented as an array of fields elements. For
each array element contains the following: `name` is the name of the
field, `entity` is the entity name to be used as a reference (optional),
`description` is the field's description, type is the field's type
(optional), `key` is true if the field is a primary key, `ref` is the
reference to the other entity's field and `required` is true if property value is mandatory.
* `fetch(params, onSuccess, onFailure)` method to query data, where params is an object, with
properties as defined in this module's model's parameters, onSuccess is a success callback and onFailure is failure callback.
* `apply(log, onSuccess, onFailure)` method to save the data, where log is an array represents
the log of changes made by clients or server side data driven code to be
applied, onSuccess is a success callback and onFailure is failure callback.

Example of an datasource module usage is as the follows:

[source,Javascript]
--------------------------------------------------

/**
 * @constructor 
 */
function DataSourceModule(){
    var self = this;
    
    this.schema = [
        {name: "p1",
         entity: "entity",
         description: "p1 desc",
         type: String,
         key: true},
        {name: "p2",
         entity: "entity",
         description: "p2 desc",
         type: String,
         ref: {property: "referencedPropertyName",
               entity: "referencedEntityName"}},
        {name: "property3Name",
         entity: "optionalEntityName",
         description: "p3 desc",
         type: Number,
         required: true},
    ];

    this.params = [
         {name: "param1Name", type: String}
         {name: "param2Name", type: Date}
    ];
    
    this.fetch = function(aParams, aOnSuccess, aOnFailure) {
        return [
            {p1: "nameA",
             p2: "descriptionA",
             p3: 2},
            {p1: "nameB",
             p2: "descriptionB",
             p3: 20}
        ];
    };

    this.apply = function(aLog, aOnSuccess, aOnFailure) {
        P.Logger.info("Log length: " + aLog.length);
        for (var i = 0; i < aLog.length; i++) {
            var change = aLog[i];
            // some work on applying a change
        }
        if (aOnSuccess) {
            // TODO : place here your asynchronous data storing code.
            // aOnSuccess(/*number of changed objects in backend*/);
        } else {
            // TODO : place here your synchronous data storing code.
            return /*number of changed objects in backend*/;
        }
    };
--------------------------------------------------

[[server-modules]]
Server modules
--------------

This section provides information how to use special features of
JavaScript modules running on an application server.

[[statefull-and-stateless-session-modules]]
Statefull and stateless session modules
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

A module being created on server is stateful by default. Such module
exists in the context of the current user session.

Mark a module with `@stateless` annotation if you want to make the
module stateless. A new instance of stateless module is created every
time the module is called via a RPC or via LPC.

[[resident-module]]
Resident module
~~~~~~~~~~~~~~~

Use `@resident` annotation to make a server module resident. A resident
modules are loaded and instantiated during server startup. Resident
modules reside in the system session. They are can't be stateless.

[[data-validators]]
Data validators
~~~~~~~~~~~~~~~

Use annotation `@validator data_source_name,  ...`, where data_source_name is a data source
name to enable server side validation. Implement validation logic in the
instance metheod `validate(log, datasource, onSuccess, onFailure)`, where log is an array of changes
representing the log of changes made by clients or server side data
driven code to be applied, `datasource` is a datasource name mentioned in `@validator` annotation
(relational datasource or script datasource module name), onSuccess is
a success cakkback and onFailure is failure callback. The method returns `false` to stop
validating process (e.g. break validators chain), nothing or true
otherwise or calls a onFailure if validation fails.

A module with no data sources in `@validatior` annotation is invoked for
default application datasource.

Server-side validator example is as follows:

[source,Javascript]
-----------------------------------------------------------

/**
 * @constructor
 * @validator DataSource1
 */ 
function ValidatorA(){
    var self = this;
    this.validate = function(log, datasource, onSuccess, onFailure) {
        return false;
    };
}
-----------------------------------------------------------

[[tips-and-tricks]]
Tips and tricks
~~~~~~~~~~~~~~~


[[scripting-java]]
Scripting Java
--------------

Calling Java classes from JavaScript code is possible for applications,
which are executed in the Platypus J2SE or on the application server
in any configuration.

To access the Java packages and classes, use the Java global object as described
in articles about integrating Nashorn and Java.

[[lpc]]
Local procedure calls
--------------

Use local procedure calls (LPC) in JavaScript for tasks, which have to be executed in parallel manner.
The LPC mechanism might is available only in application server (both Platypus TSA server or J2EE server).

To run a JavaScript code in parallel, create server module containing some logic processing one task.
Than use it multiple times in other module through LPC. 

Imagine, that we have task to compute tangent 100 time for different angles. Let's create worker module,
which will be executed multiple times in parallel:

[source,Javascript]
---------------------------- 
/**
 * @constructor
 * @stateless
 */
function Worker(){
    var self = this;

    this.calc = function (aAngle) {
      return Math.tan(aAngle);// one of parallel operations here
    }
}
----------------------------

Now let's create session statefull module, serving user's request and performing all calculations:

[source,Javascript]
----------------------------------------------------------
/**
 * @constructor
 * @public
 */
function Processor(){
    var self = this;
    this.process = function(aAngles, aOnSuccess){
        var results = [];
        var w = new P.ServerModule('Worker');
        var calced = 0;
        aAngles.forEach(function(aAngle){
            w.calc(aAngle, function(aTan){// Call to LPC stub. Actual calc function will be called by Platypus.js runtime probably in several concurrent threads.
                results.push(aTan);
                if(results.length === aAngles.length){
                    aOnSuccess(results);
                }
            });
        });
    }
}
----------------------------------------------------------

Unlike HTML5 Workers, LPC mechanism in Platypus.js uses standard container's thread pool
and so, maximum number of concurrent threads is less or equal to container's thread pool
maxThreads configuration parameter. Platypus.js supports asynchronous IO model and so maxThreads parameter
should be configured as number of processors/core of the computer + 1. 

There are three levels of parallelism in Platypus.js server environment:
* Resident modules level.
* Session modules level.
* Stateless modules level.
Each level of parallelism considers its own script spaces (script context and global object) magaging policy.
Resident modules level owns a single script space and all calls to arbitrary resident modules are
added to the same queue. Session statefull modules level considers the following: Each user's session has its own
script space and all calls to arbitrary session statefull modules are
added to the session's queue. Stateless modules level considers the following: Each instance of stateless module
creates its own script space and a call to the module and all calls to its callbacks are added toits own queue.

LPC allows to make calls one module from one level to another module from another level of parallelism and
pass some arguments to them and obtain results of such calls. To avoid concurrency in using JavaScript engine
Platypus.js runtime uses http://www.w3.org/TR/html5/infrastructure.html#safe-passing-of-structured-data[structured copy algorithm] while
passing arguments and while retrieving results.

[[logging]]
Logging
-------

The logging subsystem is built on the base of the Java Logging
infrastructure.

To write into the log, use the `Logger` object, which is a shell for the
java.util.logging.Logger class. The `Logger` object is also available in
the HTML5 web browser client.

Example of using the `Logger` object:

[source,Javascript]
------------------------------- 
P.Logger.info("info text");
P.Logger.warning("warning text");
P.Logger.severe("severe error");
-------------------------------

Check the Administration Guide and Java documentation for information
about configuring logging subsystem.

[[filesystem-io]]
Filesystem I/O
--------------

To read and write files, use Java API from the `java.io.*` and other
dedicated packages.

To read and write strings, use `readString(, )`, and `writeString(, , )`
global functions, where `path` is a path to the file, `text` is a
string, `encoding` is the name of encoding. The `encoding` parameter in
both functions is optional and by default is set for the UTF-8 encoding.

Example of using functions for reading and writing strings to a file:

[source,Javascript]
-------------------------------------------------------

//Read from one text file and write to another
var str = P.readString('/home/user1/Documents/doc1.txt');
P.writeString('/home/user1/Documents/doc2.txt', str);
-------------------------------------------------------