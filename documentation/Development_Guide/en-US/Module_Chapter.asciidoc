= JavaScript modules
[[javascript-module]]

Module is a JavaScript file containing the constructor function for global module and
define() call for AMD modules and some specific resources.
Modules contain data model responsible for data access and <ModuleName>.model file contains
its data model definition.

Modules can be executed both under JVM (in a JavaSE client and server) on Oracle Nashorn
JavaScript engine or in a HTML5 compatible browser.

== New module creation
[[new-module-creation]]

To create a new module, perform the following actions:

* Select New in the parent directory context menu, or select the parent
directory and click New Fil–µ in the main menu, or click New File on the
toolbar, or use a corresponding shortcut.
* Select Module type in the context menu, or select Choose file type
Platypus application elements Module on the wizard first step and click
Next.
* Enter the name of a new application element in the Name field and
click Finish to create it, or click Cancel to cancel.

== JavaScript code editor
[[javascript-code-editor]]

You can edit the module code in the JavaScript code editor. To open the
application element editor, double-click an application element in the
project tree.

To edit the JavaScript code:

* Open the Source tab of the module editor.
* Change text in the JavaScript code editor.
* Use the code completion for field names and functions of objects and
modules.
* Use automatic transition to declarations of variables, functions, and
to the functions of other modules; to do this, click a module name or
function while holding down the Ctrl key.
* Use context menus and shortcuts to use built-in editor functions.
* Save the application element by clicking Save All on the Platypus
Application Designer toolbar or by using the Ctrl S keyboard shortcut.

-------------------------------------------------------------------------------------------
*Note*

Use the editor's context menu Format menu item to format the JavaScript
code automatically.
-------------------------------------------------------------------------------------------

If necessary, configure the code editor parameters; to do this:

* Select the following main menu items: Tools Options.
* In the Options properties dialog, select the Editor tab.

To configure auto completion modes, go to the Code Completion tab and
enable or disable corresponding options.

== Module system
[[module-system]]

Using modules allows you to manage the complexity of your application according to the
object-oriented programming principles.

Module is an analog of a class in other programming languages, such
as in Java or in C++.

Modules in Platypus.js can be either https://en.wikipedia.org/wiki/Asynchronous_module_definition[AMD] modules and global modules.

=== AMD Modules
[[modules-amd]]

Every AMD module contains strictly one call to a global function `define`.
The `define` function should be used as follows:

[source,Javascript]
------------------------------- 
/**
 * Module description goes here
 *
 * @rolesAllowed admin
 */
define('ModuleA', ['logger', 'other-super-module'], function(Logger, OtherModule){
    function ModuleConstructor(p) {
      ...
    }

    function otherFunction() {
      ...
    }
    return ModuleConstructor;
});
-------------------------------
Define function call can have a header, which is represented as a
comment in the JsDoc format and is located at the top of the module `define` call.

The first argument in three argument version of define function allows to assign a short name to the defined module.
If this annotation is absent, module name will be formed as relative path from
'app' directory in application project and without .js filename extension and without leading slash.
So if you use two argument version of define in file 'app/folder/module.js', the module name will be 'folder/module'.

The `define` function of the module is called only once per script global object (script space).
So it is easy to implement such patterns as singleton and JavaScript class pattern.

The first argument of define function may be omitted if the module has no dependencies.
Also, the first argument may be an empty array or a single sitring literal/variable.

Module names in dependencies list may be formed using filesystem reserved directories names ('../', '../../', './').
So, if you have a module in file 'app/folder/module.js' and it depends on module located in file
'app/utility.js', than define call in module 'folder/module' may look like:

[source,Javascript]
------------------------------- 
define(['../utility', 'other-super-module'], function(Utility, OtherModule){
    function ModuleConstructor(p) {
      ...
    }

    function otherFunction() {
      ...
    }
    return ModuleConstructor;
});
------------------------------- 

Typically, `define`'s callback returns module definition as JavaScript "class" constructor. 
This constructor will be used by depending code to create module's "class" instances.
On the other hand, `define`'s callback is free to return plain JavaScript object and depending code will
recieve exactly this object regardless of how many times the module is required.

Create an instance of AMD module with the help of the `new` keyword,
using a module constructor, for example:

[source,Javascript]
---------------------------- 
require('ModuleA', function(ModuleA){
    var moduleInstance = new ModuleA();
});
----------------------------

where `ModuleA` is a module "class"'s constructor.

=== Global modules
[[modules-global]]

Global module is a JavaScrpit file without `define` call.
In general, such modules provide module constructor global function.

Constructor function can have a header, which is represented as a
comment in the JsDoc format and is located at the top of the module constructor
function definition.

Example of a module with a header:

[source,Javascript]
------------------------------- 
/**
 * Module description goes here
 *
 * @constructor
 * @rolesAllowed admin
 *
 */
function ModuleConstructor(p) {
  ...
}

function otherFunction() {
  ...
}
-------------------------------

If a JavaScript file contains exactly one top-level function, this
function is considered as a module constructor, otherwise the module
constructor must be marked with the `@constructor` annotation.

In addition to the `@constructor` annotation, a header may contain the module
description, annotations for defining security constraints and other
JsDoc annotations.

Create global module's "class" instance by the following ways:

* Create an instance of the module with the help of the `new` keyword,
using a module constructor, for example:
+
[source,Javascript]
---------------------------- 
var moduleInstance = new ModuleA();
----------------------------
+
where `ModuleA` is a module constructor.

* Create an instance of the module with the help of the `new` keyword
using global object and its properties, for example:
+
[source,Javascript]
---------------------------------- 
var global = this;// Somewhere in global namespace
var moduleName = getPrincipalStartView();// Some impersonate technique
var moduleInstance = new global[moduleName]();
----------------------------------
+
where `moduleName` is the module constructor name, for example, `"WebModule"`;

=== Modules instance functions and properties
[[modules-members]]

Specify module instance methods:

[source,Javascript]
----------------------------------------------------------

function ModuleA() {
   
   this.somePublicMethod = fucntion(p) { //instance method
      ...
   }

}
----------------------------------------------------------

Add module scope methods and fields:

[source,Javascript]
----------------------------------------------------------

function ModuleB() {
   var a, b, c;//private `fields`

   this.somePublicMethod = function(p) { //instance method
      ...
   }

   function somePrivateMethod() { //scope function
      ...
   }
}
----------------------------------------------------------

== Dependencies of AMD modules resolving
[[dependencies-resolving-amd]]

Dependencies resolution for AMD modules is based on AMD specification.

== Dependencies of global modules resolving
[[dependencies-resolving-global]]

When executing the code on an application server or on a client, all application elements,
on which initial application element depends, are loaded during the process of dependencies
resolution.

Dependencies resolution for global modules in Platypus.js is automatic and works as follows:

* The source code is analyzed and expressions of the following types are
searched for the following expressions:
+
`new ModuleName()`
+
`new Rpc.Proxy("Implementation")`
+
where `ModuleName` is the name of the module and `Implementation` is module name
wich is executed on the server side.

* Application elements with the specified names are loaded or server
proxies for server modules are generated.
* The process continues recursevly for the loaded modules, except for
the server proxies.

If it is not necessary or not possible to resolve the dependency
automatically, for example, if you want to determine the called module
in a dynamic manner, you can use the manual dependencies resolving with
global `require` function.

Use `require([param], callback)` function, where `param` is the module
name (short name or relative module name, inlcluding '../', './' names parts),
or an array of such elements, `callback` is a function,
which will be called when all the specified modules are downloaded and
executed. Both synchronous and asynchronous modes of `require` function calls are supported.
If callback is omitted, than synchronous version of function is used.

NOTE: Don't use manual dependencies resolving against a server modules. It
will lead to an attempt to download the module body on the client.

Example of using manual dependencies resolving is as follows:

[source,Javascript]
------------------------------------------------

require(['Module1', 'Module2'], function(Module1, Module2) {
  var m1 = new Module1();
  m1.bar();
  var m2 = new Module2();
  m2.foo();
});
------------------------------------------------

The following example shows how to use the `require` function for
loading the module by its module name.

Relative modules names are counted off as relative path from the `app` directory of the Platypus
application project.

The `require` function also has a synchronous version, which can be used
in the server code. In this case, if you don't need to maintain
compatibility with the client's code, the second parameter is optional:

[source,Javascript]
-------------------------------------- 
require("localLib");
// LibObject is defined in localLib.js
var obj = new LibObject();
--------------------------------------

The `require` function supports relative modules names for both synchronous and asynchronous variants:
[source,Javascript]
-------------------------------------- 
require("./sublibs/sublib-a");
// SubLibObjectA is defined in sublib-a.js
var obja = new SubLibObjectA();
require("./sublibs/sublib-b", function(SubLibObjectB){
    // SubLibObjectB is defined in sublib-b.js
    var objb = new SubLibObjectB();
});
--------------------------------------

NOTE: The `require` global function acts with AMD and global modules in the same way and
passes resolved modules to its callback function or returns them if callback is omitted.
So, you can make a global module, but in depending code you may not use the corresponding global
variables. In this case global dependencies resolution mechanism will not be used.

You should pay attention to the combination of automatic and manual
dependencies resolution for global modules.
For example, in the following snippet it is not necessary to call the `require` function:

[source,Javascript]
------------------------------------------------
var moduleName1 = "SampleModule1",
    moduleName2 = "SampleModule2";
require([moduleName1, moduleName2], function(SampleModule1, SampleModule2) {
  var m1 = new SampleModule1();
  m1.bar();
  var m2 = new SampleModule2();
  m2.foo();
});
------------------------------------------------

This code leads to the automatic dependencies resolution regarding to
the SampleModule1 and SampleModule2, as calls of their constructors are
global functions and automatic dependencies resolution will be performed.

In order to avoid automatic resolving of dependencies, even if required modules are global,
explicitly specify module names in the form of string literals in the `require` function parameter:

[source,Javascript]
--------------------------------------------------------
require(["SampleModule1", "SampleModule2"], function(SampleModule1, SampleModule2) {
    var m1 = new SampleModule1();
    m1.bar();
    var m2 = new SampleModule2();
    m2.foo();
});
--------------------------------------------------------

This method of calling the `require` function excludes these explicitly
specified modules names in the first parameter from the automatic
dependencies resolution. So, `SampleModule1` and `SampleModule2` will be
loaded only when calling the `require` function, rather than before starting the
application even if required modules are global modules.

== Security
[[module_security]]

The executable module code is a resource, access to which can be
restricted on the basis of the roles. When a user with no rights to
execute some code tries to call it, a security exception is thrown.

In order to restrict access to the entire module code, add the
`@rolesAllowed`... annotation to the module header
(either in define call JsDoc section or global constructor's JsDoc section).
Specify roles, allowed to access the module code execution, in the `@rolesAllowed`
annotation, dividing them by spaces.

If the annotation is omitted, access to the module is granted to all users.

You can restrict access to the module code on the level of an particular
function. To do this, add the `@rolesAllowed` annotation to the
function's JsDoc. The restrictions on the function level have a higher
priority than the module level restrictions. For example, only a user
with the `role2` role from the following example will have access to the
`f2`:

[source,Javascript]
---------------------------- 
/**
 * @rolesAllowed role1 role2
 */
define(function(){
    function ModuleConstructor {
       var self = this;

       /**
        * @rolesAllowed role2
        */
       this.f2 = function() {
          //...
       }
    }
    return ModuleConstructor;
});
----------------------------

Use `security` module to get access to the information about the
current user in the executable code. The module has `principal` property.
The `principal` property is read-only.
This is object of information about the user and contains the `name`
property, i.e. the name of the current user, and the `hasRole()`method,
which allows you to check if this user has any role:

[source,Javascript]
----------------------------------------------------

Logger.info('Current user: ' + Security.principal.name);

if (Security.principal.hasRole('Manager')) {
  // Some operations allowed only to managers ...
}
----------------------------------------------------

Use `Security.principal.logout(onLoggedOut, onError)` function, where `onLoggedOut` is a function, which will be called
after the session is terminated and onError is a function, which will be called if an error occur.
Open forms will be closed and the user will see the login and password entering form.

== Resources loading
[[resources-loading]]

The platfrom runtime enables loading of resources in the form of binary
data and text. Resources may be loaded using their applicaion paths or
URLs. Applicaion paths are counted off from the `app` root directory of
the application project. Use the `resource` module for resource loading.

To download a resource, use the `Resource.load(path, callback)` method, where
`path` is a application path or URL, `callback(obj)` is a function, which
will be called after the resource is loaded, `obj` is an array of bytes
of the downloaded resource for the server code and Platypus Client or an
object of the ArrayBuffer type for the HTML5 browser in the case of binary data
and string in the case of text data:

[source,Javascript]
---------------------------------------------
require('resource', function(Resource){
    //Loads binary resource
    Resource.load("res/pict.bin", function(obj) {
        ...
    });
});
---------------------------------------------

[source,Javascript]
---------------------------------------------

require('resource', function(Resource){
    //Loads text resource
    Resource.load("res/list.txt", function(obj) {
      ...
    });
});
---------------------------------------------

You can use a synchronous version of this method with a single parameter
in the server code or in the code, which is executed in the J2SE Client.
In this case, the method itself will return an array of bytes of
the downloaded resource:

[source,Javascript]
---------------------------------------- 
//Loads binary resource synchronously
var Resource = require('resource');
var obj = Resource.load("res/pict.bin");
...
----------------------------------------

To get the absolute path to the `app` project directory, use the
`Resource.applicationPath` read-only property:

[source,Javascript]
-------------------------------------- 
//Reads the application's path
Logger.info(Resource.applicationPath);
--------------------------------------

== Data model
[[data-model]]

Data model is a module's persistence manager. It provides access to the
data obtained from a relational database or any other data source. Data
model allows you to perform the following tasks:

* Fetch data from the data source(s) to the entities data arrays.
* Automatically requery data, according to the inter-entities
links.
* Save changes made to the entities data (insert, update and delete).
* Entities data change events handling with JavaScript.

Data model consists of entities and links and is configured using the
visual editor.

image:images/dataModel.png[Data model structure]

Data is stored in the form of JavaScript objects within an etnity's
data array.

Entities are created using a module implements special datasouce
interface methods or a query application element.

NOTE: Table entity is a special query entity, which selects all data from
the table. It is created automatically by runtime. A table entity can be
used only in two-tier configurations with direct connection to a database.

Each entity can have parameters and contains a data array with predefined
fields according to the data schema defined by the module or query, on
the basis of which the entity is created.

In general, a data array comprised of objects, each of which corresponds
to a tuple in the query results.

There is a cursor for each enitity. The cursor can point to some element in
the data array and determines the `current` item of this entity. Also the
cursor can point to null. The entity cursor value can affect to the
linked entities data.

Entity fields and parameters may be connected by links. The following
link types are used in a data model:

* Query link connects `source` field of one entity with another entity parameter as `target` field.
* Reference link defined by ORM on the basis of foreign keys derived from database/script datasource structure.

Query link requeries the target entity's data array according to the
parameter value change. The new parameter value is determined according
to the source point of the link. Both entitiy's cursor property's value or a
parameter value can be used. When the value at the link source changes,
new data is requested from the database or application server and reoladed in the target
entity data array.

Reference link is defined by a database table/script datasource structure foreign keys.
This kind of link is created automatically, if a entitiy's schema contains fields included
to such foreign key. This type of link does not affect the content of
the data arrays and is used to generate inter-element connections between
element of entities' data arrays. This is done via new properties, wich are created
while data fetching. The link of this type is visually shown as a dashed
line on the data model diagram.

------------------------------------
*Note*

To get inter-instance connections work, primary and foreign keys are
required. Such keys may come from database structure definitions or from
schema definitions in a JavaScript datasource module.
------------------------------------

image:images/dataModelLinks.png[Query and filtration types links]

The figure shows an example of operation of query links for
the three entities in the data model. In the `Persons` entity, a cursor
is pointing to a string corresponding to a person named `Mike`.

When initializing a module, data corresponding to the input parameter
values is loaded into the model by default, then every change of input
parameters leads to a cascade update of all datasets, which are directly
or inderectly associated with the modified parameter.

For any entity you can determine any number of incoming and outgoing
links of both types. When building connections you should consider the
following restrictions:

* Links must not create circular references.
* Linked fields and parameters of the source and the target entities must
match by thiers type. The types of connected fields and parameters must
allow the mutual conversion of values. For example, it is possible to
connect field if there's a number specified for the connection on the
source, and a string specified the connection on the target, it is quite
possible, since there is a possibility of an unambiguous conversion of a
number to a string, but not vice versa.

Added, deleted and changed objects of these entities objects are saved
to the database or sent to the application server for subsequent saving
when calling the save function of the data model object.

The data model object is represented in the module by the
result of call to `Orm.loadModel(name)` function, where name is name of already loaded module.

Create a variable for the data model object and assign result of P.loadModel() to it. 
In the following code snippets we will use such variable:

[source,Javascript]
-------------------------- 
define('ModuleD', 'orm', function(Orm, ModuleName){
    return function () {
       var model = Orm.loadModel(ModuleName);
       //...
    }
});
--------------------------

or as a global module:

[source,Javascript]
-------------------------- 
function ModuleD(Orm) {
    var self = this;
    var model = Orm.loadModel(this.constructor.name);
    //...
}
--------------------------

* Set the data model parameters to update the data of the linked
entities.
* Get access to data for data processing, analysis, and so on.
* Use inter-instances connections to process the data in ORM manner.
* Use the cursor as "current" data array element pointer.
* Specify entity event handler functions and write their JavaScript
code.
* Alter, remove or add objects in the entity's data array and allow the data model to
save the changes.
* Read entity schema (fields metadata) for special needs.

To force refetch of all data model entities' data arrays, call the requery function
of the `model` object:

[source,Javascript]
----------------------------------- 
model.requery(onSuccess, onFailure)
-----------------------------------

where `onSuccess` is the handler function for refresh data on success
event (optional), `onFailure` is the handler function for refresh data
on failure event (optional).

=== Data model editor
[[data-model-editor]]

Data model is configured using the visual editor.

For navigating to a data model elements, it is convenient to use a data
model inspector panel. In the data model inspector, entity and model
parameters are presented in the form of a tree structure. You can select
an entity or a connection both in the visual editor and in the data
model inspector. Mutual positioning of the model data inspector and its
diagram is possible.

To add a table entity to the data model, perform the following steps:

* Select the Datamodel tab of the module's editor.
* Select the Add query / Add table Add table menu item on the editor
toolbar, or use the Ctrl Shift Insert shortcut.
* Select the table from the list in the table selection dialog, if
necessary select a schema from the drop-down Schema list; the Default
button sets the default schema for the application; use the search
option by clicking Find, if necessary.
* Click OK add the table or click Cancel to cancel.
* If necessary, move the table on the model diagram to the right place.
* Save the application element by clicking Save All on the main toolbar
or by using the Ctrl Shift S keyboard shortcut.

To add an entity based on an existing query to the data model, perform
the following actions:

* Select Add query / Add table Add query on the editor toolbar.
* Select an application element of the Query type in the dialog.
* Click OK to add the query or click Cancel to cancel.
* If necessary, move the query on the visual editor diagram to the right
place.
* Save the application element by clicking Save All on the main toolbar
or by using the Ctrl Shift S keyboard shortcut.

---------------------
*Note*

Drag an existing query or a module from the application elements tree on
the project panel to the visual editor diagram of the data model to
include it into the editable data model.
---------------------

An entity object and its data is available to module's JavaScript
code. When you add a new entity, its name will be specified by default,
according to the query, or module consturctor name or a table name in
the database. To change the name of the entity, perform the following
steps:

* Go to the Datamodel tab.
* Select the corresponding entity on the data model diagram or in the
data model inspector.
* In the Properties editing window specify the name value in the name
field. Entity name is case-sensitive and must meet the requirements for
the JavaScript identifiers.
* Save the application element by clicking Save All on the main toolbar
or by using the Ctrl Shift S keyboard shortcut.
----------
*Note*

If the Properties panel is not displayed, enable this panel. To do this,
select Window Properties in the Platypus Application Designer main menu.
----------

To delete an entity from the data model, perform the following actions:

* Select an entity in the data model inspector or on the diagram.
* Click Delete on the editor toolbar.
* Save the application element by clicking Save All on the main toolbar
or by using the Ctrl Shift S keyboard shortcut.

To add a query link between two entites:

* Move the field or parameter to the parameter of an entity, with which you want to
make dependent on the first entity. The connection will be displayed as a line with
an arrow between parameters or field/parameter of theese two entities.
* Save the application element by clicking Save All on the main toolbar
or by using the Ctrl Shift S keyboard shortcut.

----------
*Note*

Query link type in the visual editor is highlighted by purple. Reference
link is highlighted by black with dashed style. The link target field is shown by an
arrow.
----------

To delete a link, perform the following actions:

* Select the link to remove by mouse click.
* Click Delete or use the Delete key.
* Save the application element by clicking Save All on the main toolbar
or by using the Ctrl Shift S keyboard shortcut.

To edit a reference link properties, perform the following actions:

* Select a dashed link by mouse click.
* Select Scalar and collection properties menu item from the foreign key
link context menu.
* In the dialog specify Scalar property name and Collection property
name fields.
* Save the application element by clicking Save All on the main toolbar
or by using the Ctrl Shift S keyboard shortcut.

To zoom-in or zoom-out the data model visual presentation:

* Click Zoom In to scale up the data model presentation in the editor;
click Zoom out to scale it down.

To use the search function on the data model diagram:

* Click Find to open the search dialog in the data model editor.
* Enter the search line, select fields to be used for searching:
Datasets, Fields, Params, and also check the necessary options: use the
Whole words option to search for the whole words. Use the Match case
option to perform the case-sensitive search.
* Click Next and Previous to go to the next or previous search result.
* Click Close to close the search dialog.

=== Entities
[[entities]]

Data model entities are available as the data model object's properties:
`model.entity1`, where `entity1` is the script presentation of an entity.

Entities may have its own parameters and can be updated independently
from the other model entities.

To access entity parameters, use the `params` entity property:

[source,Javascript]
-------------------------- 
var entityParams = model.entity1.params;
--------------------------

where `entity1` is an object of the corresponding entity.

To access the specific parameters, use properties of the `model.entity1.params`
object with names, which match the entity parameter names:

[source,Javascript]
-------------------------------- 
var entityParam = model.entity1.params.param1;
--------------------------------

where `entity1` is an entity object,`param1` is the property of the corresponding parameter.

To set the parameter value, assign a new value to it:

[source,Javascript]
-------------------------- 
model.entity1.params.param1 = newValue;
--------------------------

where `newValue` is a new value of the parameter.

Setting a new value for a entity parameter doesn't result in automatic
update of the data array.

To update entity data and related entities, use the execute function.
New data will be loaded only if the entity parameter values were
changed:

[source,Javascript]
------------------------------- 
entity1.execute(onSuccess, onFailure);
-------------------------------

where `entity1` is an entity object, `onSuccess` is the handler function for 
success event (optional) and `onFailure` is the handler function failure event (optional).

To force the update of entity data and related entities, use the requery
function:

[source,Javascript]
------------------------------- 
model.entity1.requery(onSuccess, onFailure);
-------------------------------

where `entity1` is an entity object, `onSuccess` is the handler function for
success event (optional), `onFailure` is the handler function failure event (optional).
Callback functions are called when the database request is executed and its results
come to the client over the network.

Handler of the `onRequeried` entity event will be called in any case,
regardless of the method of calling the `requery` function.

To query new entity data, but leave entity's parameters, data array and related
entities as is, use the `query` function:

[source,Javascript]
------------------------------- 
model.entity1.query({param1: true, param2: 'some value'}, function(aNewData){
    //...
}, onFailure);
-------------------------------

where `entity1` is an entity object, first argument is parameters values,
represented as JavaScript object, second argument of `query` function is the handler function for
success event (optional) and `onFailure` is the handler function failure event (optional).
Callback functions are called when the database request is executed and its results
come to the client over the network.

To append some new elements to existing data array without adding any changes into
model's changelog, use append method of an entity:

[source,Javascript]
------------------------------- 
model.entity1.append([{id:78, name: 'Mike'}, {id:79, name: 'Juke'}]);
-------------------------------

After a data is appended to entity's data array, model is watching after it and
accumulates changes made to appended items in its change log.
This method might be used for example in a view with lazy tree widget.

To query some data and obtain sata array, wich is not watched by the model and not used as a
replacement of entity's data array, use query method:

[source,Javascript]
------------------------------- 
for(var i = 0; i < maxCount; i++){
    model.entity1.query({param1: i + 43, param2: 'Astralia'}, function(aFetchedData){
        // Some actions with fetched data
    }, function(aError){
        Logger.severe('Failed due to an error: ' + aError);
    });
}
-------------------------------

-------------------------------
*Note*

Update of entity data does not cancel the data changes made in the
entity dataset earlier, so after saving the model these changes will be
applied to the database. Data changes are reset only after saving the
entire model or explicit call to `revert` method.
-------------------------------

To access to the entity's data, refer to the entity data array as a regular
JavaScript array:

[source,Javascript]
------------------- 
var item = model.entity1[i];
-------------------

where `entity1` is an entity, `i` is an index of the array element within the
`0...length - 1` range.

The following example shows the process of enumerating document elements in
the `documents` entity's data array:

[source,Javascript]
--------------------------------------------

var documents = model.documents;

// Logs all documents names
for (var i = 0; i < documents.length; i++) {
    Logger.info(documents[i].name);
}
--------------------------------------------

If a reference link is established between two entities, you can get
access to the data of the connected entity by using data instance
property having the name configured earlier in propertoes of a link ion the datamodel designer.
This properties are generated during data fetch by Platypus.js ORM.

[source,Javascript]
-------------------------- 
var propValue = model.entity1[i].referencedObject.someData;
--------------------------

where `entity1` is the name of an entity, which contains the external key
reference, `i` is an index of the array element within the `0...length - 1`
range, entityName2 is an entity containing the field, which is
referenced by the external key, `referencedObject` is a property of reference link
configured as `scalar` and `someData` is some data field of referenced object
If the entity contains a field, which is referenced by the external key,
the property contains an array of the connected entity objects:

[source,Javascript]
-------------------------- 
var referees = model.referencedEntity[i].referees;
Logger.info("referees.length: " + referees.length);
--------------------------

where `referencedEntity` is an entity, which contains the external key reference,
`i` is an index of the array element within the `0...length - 1`, range
referees is a name of collection property name configured earlier in datamodel designer in reference link properties dialog.

Change for a foregn key link scalar and collection properties if
required via reference link properties dialog in datamodel designer.

=== Cursor API
[[cursor-api]]

To get access to the entity's "current" data array element use
the `model.entity1.cursor` property, for example:

[source,Javascript]
-------------------------------- 
var currentValue = model.entity1.cursor.price;
--------------------------------

where `entity1` is a corresponding entity, `price` is a property of interest.

The cursor points to some object, or it can be null.

After loading data array the cursor point on the first
entity's data array element.

=== Saving data
[[saving-data]]

Data model provides automatic tracking of data changes. Data
changes can be saved only as a part of entire model.

To edit, insert, or delete data, perform the following actions:

* Edit, insert, or delete an object from the entity data.
* Call the save method of the model.

To obtain access to the entity arbitrary objects, use the syntax of
referring to an array element:

[source,Javascript]
------------- 
model.entity1[i].propName = 56;
-------------

where `entity1` is an entity, entityName[i].propName is an object property
with the specified index in the entity data and `56` is an expression for the new value.

To change the appropriate property of the entity's cursor, use the
following way:

[source,Javascript]
---------- 
model.entity1.cursor.propName = 56;
----------

where `entity1` is an entity, `propName` is a property in the current cursor position in the entity
data array, `56` is an expression for the new value.

To save changes the data model changes, use its save method:

[source,Javascript]
-------------------------------
model.save(onSuccess, onFailure);
-------------------------------
where onSuccess is the handler function for an event of successfull saving of data (optional)
and onFailure is the handler function for a save data on failure event (optional).

To insert a new object to a data array and save it to datasource:

* Add a new object to entity data array by standard JavaScript array methods (push, unshift, splice).
* Call the save method of the data model.

If necessary, pass the JavaScript object, the property names of which
match the names of properties in the entity objects, as a parameter to
the function. Their values will be set as values of the new object
properties:

[source,Javascript]
-------------- 
model.entity1.push( {
  propName: 'disks',
  price: 89});
--------------

When using the push/unshift/splice function,
the cursor will point to a new object.

After inserting, the new object will have the following properties:

* An identifying property gets the generated value, if a value was not
explicitly assigned to this property when inserting.
* Properties belonging to the "key-value" get the transferred values.
* Other properties will be set to `null`.

Example of code for inserting a new object into the `documents` entity:

[source,Javascript]
---------------------------------------------------------

model.documens.push({id: 101, name: 'New document name'});
model.save(function(){});
---------------------------------------------------------

Use `elementClass` entity property to specify JavaScript constructor of entity's data array items.

Example of code that uses `elementClass` property of `documents` entity:

[source,Javascript]
---------------------------------------------------------
model.documens.elementClass = Document;// assume, that cinstructor function Document is accessible in global scope
model.documens.requery(function(){
    model.documens.forEach(function(aDoc){
        Logger.info('aDoc instanceof Document : ' + (aDoc instanceof Document));
    });
}, function(){});
---------------------------------------------------------

Use `remove` function and pass the object to be deleted or pass an array of objects to be deleted
as the parameter to avoid unnecessary iterations:

[source,Javascript]
------------------- 
model.entity1.remove(toBeDeleted);
model.entity1.remove([toBeDeleted1, toBeDeleted2, toBeDeleted3]);
-------------------

where `toBeDeleted` is the one of the data array elements.

Use the splice function to delete an object from the entity data by
passing an index and a number of elements to be deleted as arguments:

[source,Javascript]
------------------ 
model.entity1.splice(index, length);
------------------

where `entity1` is an entity, `index` is an index of the entity data array
element. `index` can take on a value within the `0...length-1` range and 
`length` is a number of elements to be deleted.

Example of deleting the current object from the `documents` entity and
from the database:

[source,Javascript]
----------------------------- 
// Removes first element
model.documents.splice(0, 1);
model.save(function(){});
-----------------------------

To remove all objects from the entity data, use the deleteAll entity
function:

[source,Javascript]
------------------- 
model.documents.splice(0, model.documents.length);
-------------------

Example of deleting all objects from the `documents` entity and from the
database:

[source,Javascript]
---------------------------- 
// Removes all elements
model.documents.splice(0, model.documents.length);
model.save(function(){});
----------------------------

Calling `save` function results in saving changes and commiting the
transaction.

Calling save function may lead to an exception, for example, if saved
data are inconsistent with the database schema. In this case data are
not saved to the database. To handle this exception, use failure callback:

[source,Javascript]
---------------------------------------- 
  model.save(function(){}, function(){
      model.revert();
      Logger.severe('Data are not saved, due to an error: ' + e);
  });
----------------------------------------

After handling the error, you can try to correct the cause of the
problem and re-call the save function.

Use model's `revert` method to revert model data changes. After this
method call, no data changes are avaliable for `save()` method, but the
model still attempts to commit. Calling `save()` on unchanged model
nevertheless leads to a commit even transaction will be empty.

=== Find API
[[find-api]]

Find operations can be performed after the data model loads its
entities' data.

Search is performed in the model and doesn't send new requests to the
database neither changes the data.

To find an object by its primary key, use the findByKey entity method by
passing a key value to it:

[source,Javascript]
----------------------------- 
var item = model.entity1.findByKey(aKey);
-----------------------------

where `entity1` is an entity, `aKey` is an expression for the search key.

If nothing is found, the findByKey function returns the `null` value.

Example of code for searching for a document by its identifier and
displaying its name in the log:

[source,Javascript]
----------------------------------------------------

var documentId = 101;
var document = model.documents.findByKey(documentId);
if (document) {
    Logger.info('Document name is ' + document.name);
}
----------------------------------------------------

To perform search by arbitrary properties, use the find
entity's function. Pass the "key-value" pairs corresponding to the
property and search value as a JavaScript object to the find function. The search
is performed by checking the equality of the entity object property
values and values to search for.

[source,Javascript]
------------------------ 
var items = model.entity1.find({
    prop1: propValue1,
    prop2: propValue2//,
    //...
    //propN: propValueN
});
------------------------

where `entity1` is an entity, `prop1` and `prop2` are an entity properties`
and `propValue1` and `propValue2` are search keys values

-------------------------------
*Note*

findByKey and find functions search for objects using prepared hash
table by corresponding properties and don't enumerate the entity's data array each time.
Therefore, it is recommended to logically separate the code for
searching and changing data, as after any change of data prepared hashes
are marked as obsolete, and are rebuilded when you attempt to perform
the search next time.
-------------------------------

This code snippet illustrates search documents by their names and by the
set flag:

[source,Javascript]
--------------------------------------------

var documentName = 'Document 1';
var isChecked = true;
var documents = model.documents;
var foundDocuments = documents.find({
    name: documentName,
    checked: isChecked
});
foundDocuments.forEach(function(aFoundDocument){
    Logger.info(foundDocument.desc);
});
--------------------------------------------

=== Sort API
[[sort-api]]

To sort entities' data arrays use standard JavaScript array `sort` function.

=== Entity events
[[entity-events]]

To implement some logic to react to the data events specify entity
events handlers functions. To create these handler functions assign
functions to entities' properties.

Entity data events list is given in the table below:

[cols="<,<,<",options="header",]
|=======================================================================
|Event |Event type |Description
|`onRequeried` |`EntityEvent` |Is called after re-requesting the entitiy's data
array.

|`onDeleted` |`DeleteEvent` |Is called after removing an object from the
entitiy's data array.

|`onInserted` |`InsertEvent` |Is called after inserting a new object
into the entitiy's data array.

|`onScrolled` |`ChangeEvent` |Is called after changing the cursor
in the entity's data array
|=======================================================================

`EntityEvent` is a generic entity object and contains the following
property:

[cols="<,<",options="header",]
|==============================
|Property |Description
|`source` |Event source object.
|==============================

Other entity events contain `source` property as in `EntityEvent`, as
well as their own specific properties.

`ChangeEvent` object specific propetries are listed in the following
table:

[cols="<,<",options="header",]
|======================================
|Property |Description
|`propertyName` |Changed property name.
|`oldValue` |The value before change.
|`newValue` |The value after change.
|======================================

`DeleteEvent` object specific propetries are listed in the following
table:

[cols="<,<",options="header",]
|==============================
|Property |Description
|`deleted` |The deleted objects.
|==============================

`InsertEvent` object specific propetries are listed in the following
table:

[cols="<,<",options="header",]
|================================
|Property |Description
|`inserted` |The inserted objects.
|================================

=== Data schema
[[data-schema]]

JavaScript code has access to an entity's fields metadata. It is
possible to read types, names, descriptions of entity properties and
parameters, and etc.

To read an entity's schema, use its `schema` property:

[source,Javascript]
----------------------------------- 
var entityMetadata = model.entity1.schema;
-----------------------------------

where `entity1` is an entity, which schema you are interested in.

To get access to the an entitiy's property metadata:

[source,Javascript]
---------------------------------- 
var propMetadata = model.entity1.schema.prop1;
----------------------------------

where `entity1` is an entity, `prop1` is the name of the corresponding property.

Example of code, which checks if the `id` property of the documents
entity is an object's key property.

[source,Javascript]
------------------------------------------------

if (model.documents.schema.id.pk) {
    Logger.info('id is key attribute of decuments entity.');
}
------------------------------------------------

The schema composed of the following properties:

[cols="<,<,<",options="header",]
|=======================================================================
|Property |Type |Description
|`pk` |Boolean |`true`, if the property is a key

|`name` |String |Property name

|`description` |String |Property description

|`readonly` |Boolean |`true`, if the property is read-only

|`size` |Number |Size of the property value

|`nullable` |Boolean |`true`, if the property can take on the `NULL`
value
|=======================================================================

To get the number of properties in the entity, use the `length` property
in the entity schema object:

[source,Javascript]
-------------------- 
model.entity.schema.length
--------------------

NOTE: If some field will have name as `length`, than its name will have a priority
and it will be impossible to determine length of .schema as in above example.

You can read the property's metadata by index as an array element:

[source,Javascript]
--------------- 
model.entity1.schema[i]
---------------

where `entity1` is an entity, and `i` is within the range from `0` to `entityMetadata.length - 1`.

Below you can find an example of output all properties of the documents
entity into the log:

[source,Javascript]
---------------------------------------------------------

for (var i = 0; i < model.documents.schema.length; i++) {
    Logger.info(documents.md[i]);
}
---------------------------------------------------------

To read the entity parameter metadata, use the `schema` property of the
`params` object of an entity:

[source,Javascript]
------------------------------------------

var paramsMetadata = model.entity1.params.schema;
------------------------------------------

You can read metadata composed of the following for the parameter:

[cols="<,<,<",options="header",]
|=======================================================================
|Property |Type |Description
|`modified` |Boolean |`true`, if the parameter was changed and `false`
otherwise

|`pk` |Boolean |`true`, if the parameter is a primary key and `false`
otherwise

|`name` |String |Name of the parameter

|`description` |String |Description of the parameter

|`readonly` |Boolean |`true`, if the parameter is read-only and `false`
otherwise

|`size` |Number |Size of the property value

|`nullable` |Boolean |`true`, if the parameter is not mandatory and
`false` otherwise
|=======================================================================

To get the number of the entity parameters:

[source,Javascript]
--------------------------- 
model.entity1.params.schema.length
---------------------------

where `entity1` is an entity.

NOTE: If some parameter will have name as `length`, than its name will have a priority
and it will be impossible to determine length of .schema as in above example.

=== Dynamic entities
[[dynamic-entities]]

Use model's loadEntity(queryName) method, where queryName is the name of
the query to dynamically create an entity in the data model. The
generated entity can be used to read, insert or modify objects:

[source,Javascript]
---------------------------------------------------

var docEntity = model.loadEntity("Documents");
docEntity.requery(function(){}, function(){});

//Print all documents names
docEntity.forEach(function(doc) {
    Logger.info(doc.NAME);
});

//Change first document's name
docEntity[0] && docEntity[0].NAME = "New document";
model.save(function(){}, function(){});
---------------------------------------------------

Use model's createEntity(sqlText, datasourceName) method, where sqlText is arbitrary sql text
and is datasourceName the name of datasource accessible in your current environment
The generated entity can be used to read, insert or modify objects:

[source,Javascript]
---------------------------------------------------

var docEntity = model.createEntity("select * from tr_documents", "testdb");
docEntity.requery(function(){}, function(){});

//Print all documents names
docEntity.forEach(function(doc) {
    Logger.info(doc.NAME);
});

//Change first document's name
docEntity[0] && docEntity[0].NAME = "New document";
model.save(function(){}, function(){});
---------------------------------------------------

Use executeUpdate entity method to execute the SQL code, which contains
the `INSERT`, `UPDATE`, `DELETE` or DDL commands:

[source,Javascript]
----------------------------------------------------------------------------

var e = model.createEntity("DELETE * FROM Document d WHERE d.DOC_TYPE = 1");
e.executeUpdate(function(){}, function(){});
----------------------------------------------------------------------------

NOTE: createEntity method may be used only is two-tier environment. E.g. in Java EE
server, J2SE client or in Platypus TSA server.

=== Executing arbitary SQL
[[executing-arbitary-sql]]

In addition to using entities based on a query, data model allows to
execute arbitrary SQL code. Using entities based on a query instance
have a number of advantages, such as security management or ability to
work with the client code. However, if necessary, you can execute
arbitrary SQL.

SQL execution is available on a server or on a desktop client wich has a
direct connection to a database.

Use executeSql(sqlClause, datasourceName, onSuccess, onFailure) model's method to execute the SQL code, which
contains the `INSERT`, `UPDATE`, `DELETE` commands, where `sqlClause` is the query text:

[source,Javascript]
---------------------------------------- 
model.executeSql("DROP TABLE Document", "testdb", function(){}, function(){});
----------------------------------------

== Data source module
[[data-source-module]]

A module can be used as a data source in other modules' data models just
like a query.

To create a data source module implement the following instance
properties and methods:

* `schema` property to represent the data source metadata information.
The schema information is repesented as an array of fields elements. For
each array element contains the following: `name` is the name of the
field, `entity` is the entity name to be used as a reference (optional),
`description` is the field's description, type is the field's type
(optional), `key` is true if the field is a primary key, `ref` is the
reference to the other entity's field and `required` is true if property value is mandatory.
* `fetch(params, onSuccess, onFailure)` method to query data, where params is an object, with
properties as defined in this module's model's parameters, onSuccess is a success callback and onFailure is failure callback.
* `apply(log, onSuccess, onFailure)` method to save the data, where log is an array represents
the log of changes made by clients or server side data driven code to be
applied, onSuccess is a success callback and onFailure is failure callback.

Example of an datasource module usage is as the follows:

[source,Javascript]
--------------------------------------------------

/**
 * @constructor 
 */
function DataSourceModule(){
    var self = this;
    
    this.schema = [
        {name: "p1",
         entity: "entity",
         description: "p1 desc",
         type: String,
         key: true},
        {name: "p2",
         entity: "entity",
         description: "p2 desc",
         type: String,
         ref: {property: "referencedPropertyName",
               entity: "referencedEntityName"}},
        {name: "property3Name",
         entity: "optionalEntityName",
         description: "p3 desc",
         type: Number,
         required: true},
    ];

    this.params = [
         {name: "param1Name", type: String}
         {name: "param2Name", type: Date}
    ];
    
    this.fetch = function(aParams, aOnSuccess, aOnFailure) {
        return [
            {p1: "nameA",
             p2: "descriptionA",
             p3: 2},
            {p1: "nameB",
             p2: "descriptionB",
             p3: 20}
        ];
    };

    this.apply = function(aLog, aOnSuccess, aOnFailure) {
        Logger.info("Log length: " + aLog.length);
        for (var i = 0; i < aLog.length; i++) {
            var change = aLog[i];
            // some work on applying a change
        }
        if (aOnSuccess) {
            // TODO : place here your asynchronous data storing code.
            // aOnSuccess(/*number of changed objects in backend*/);
        } else {
            // TODO : place here your synchronous data storing code.
            return /*number of changed objects in backend*/;
        }
    };
--------------------------------------------------

== Server modules
[[server-modules]]

This section provides information how to use special features of
JavaScript modules running on an application server.

=== Statefull and stateless session modules
[[statefull-and-stateless-session-modules]]

A module being created on server is stateful by default. Such module
exists in the context of the current user session.

Mark a module with `@stateless` annotation if you want to make the
module stateless. A new instance of stateless module is created every
time the module is called via a RPC or via LPC.

=== Resident module
[[resident-module]]

Use `@resident` annotation to make a server module resident. A resident
modules are loaded and instantiated during server startup. Resident
modules reside in the system session. They are can't be stateless.

=== Data validators
[[data-validators]]

Use annotation `@validator data_source_name,  ...`, where data_source_name is a data source
name to enable server side validation. Implement validation logic in the
instance metheod `validate(log, datasource, onSuccess, onFailure)`, where log is an array of changes
representing the log of changes made by clients or server side data
driven code to be applied, `datasource` is a datasource name mentioned in `@validator` annotation
(relational datasource or script datasource module name), onSuccess is
a success cakkback and onFailure is failure callback. The method returns `false` to stop
validating process (e.g. break validators chain), nothing or true
otherwise or calls a onFailure if validation fails.

A module with no data sources in `@validatior` annotation is invoked for
default application datasource.

Server-side validator example is as follows:

[source,Javascript]
-----------------------------------------------------------

/**
 * @constructor
 * @validator DataSource1
 */ 
function ValidatorA(){
    var self = this;
    this.validate = function(log, datasource, onSuccess, onFailure) {
        return false;
    };
}
-----------------------------------------------------------

//=== Tips and tricks
//[[tips-and-tricks]]


== Scripting Java
[[scripting-java]]

Calling Java classes from JavaScript code is possible for applications,
which are executed in the Platypus J2SE or on the application server
in any configuration.

To access the Java packages and classes, use the Java global object as described
in articles about integrating Nashorn and Java.

== Remote procedure calls
[[modules-rpc]]

To use a server module on client (browser or J2SE platypus client) via remote procedure call mechanism,
create a proxyb for the server module as follows:

[source,Javascript]
---------------------------------------- 
var moduleProxy = new Rpc.Proxy("Processor");
----------------------------------------

where `Processor` is either short or relative server module name. The server module
should be marked with the `@public` annotation to enable access via the network.
Server modules, with is used only within application server don't need the `@public` annotation
to be used with LPC.

To call the module's instance method, use the following structure, for
example:

[source,Javascript]
------------------------------------------

moduleInstance.getResult(10, function(aResult){
    var result = aResult;
});
------------------------------------------

== Local procedure calls
[[lpc]]

Use local procedure calls (LPC) in JavaScript for tasks, which have to be executed in parallel manner.
The LPC mechanism is available only in application server (both Platypus TSA server or J2EE server).

To run a JavaScript code in parallel, create server module containing some logic processing one task.
Than use it multiple times in other module through LPC. 

Imagine, that we have to compute tangent several times for different angles. Let's create a worker module,
which will be executed multiple times in parallel:

[source,Javascript]
---------------------------- 
/**
 * @constructor
 * @stateless
 */
define('Worker', [], function Worker(){
    var self = this;

    this.calc = function (aAngle) {
      return Math.tan(aAngle);// one of parallel operations here
    }
});
----------------------------

Now let's create session statefull module, serving user's request and performing all calculations:

[source,Javascript]
----------------------------------------------------------
define('Processor', 'rpc', function(Lpc){
    return function (){
        var self = this;
        this.process = function(aAngles, aOnSuccess){
            var results = [];
            var w = new Lpc.Proxy('Worker');
            var calced = 0;
            aAngles.forEach(function(aAngle){
                w.calc(aAngle, function(aTan){// Call to LPC stub. Actual calc
                                              // function will be called by 
                                              // Platypus.js runtime probably in
                                              // several concurrent threads.
                    results.push(aTan);
                    if(results.length === aAngles.length){
                        aOnSuccess(results);
                    }
                });
            });
        }
    };
});
----------------------------------------------------------

Unlike HTML5 Workers, LPC mechanism in Platypus.js uses standard container's thread pool
and so, maximum number of concurrent threads is less or equal to container's thread pool
maxThreads configuration parameter.

NOTE: Platypus.js supports asynchronous IO model and so maxThreads parameter in most cases should be configured
as number of processors/cores of the computer + 1.

There are three levels of parall execution in Platypus.js server environment:

* Resident modules level.
* Session modules level.
* Stateless modules level.

Each level of parall execution considers its own script spaces (script context and global object) magaging policy.
All resident modules own a single script space and all calls to arbitrary resident modules are
added to the same queue.

Session statefull modules level considers the following: Each user's session has its own
script space and all calls to arbitrary session statefull modules are
added to the session's queue.

Stateless modules level considers the following: Each instance of stateless module
creates its own script space and a call to the module and all calls to its callbacks are added to its own queue.

LPC allows one module from one level to make calls to another module from another level of parall execution and
pass some arguments to them and obtain results of such calls. To avoid concurrency in using JavaScript engine,
Platypus.js runtime uses asynchronous IO and callbacks mechanism. Also, it uses
http://www.w3.org/TR/html5/infrastructure.html#safe-passing-of-structured-data[structured copy algorithm] while
passing arguments and while retrieving results.

== WebSocket in platypus.js applications
[[websocket]]

Platypus.js applications can handle WebSocket messages. Regular server modules can be used as WebSocket endpoints.
Websocket endpoint server modules are subject of security checks as well as other server modules.
Note, that each WebSocket client uses its own network session and so, session server modules are created in context
of each WebSocket client object. So, if you want to account multiple WebSocket clients, then you need a resident module
to hold accounting data structure.

Example of WebSocket messages handling with cross sessions client endpoints is shown in the the following examples.

This example shows resident module, that holds information on currently connected WebSocket clients.

[source,Javascript]
-------------------------------
/**
 * Assume this server module has file driven module name - WebSocket/ChatAccounter
 * @resident
 */
define(function(){
    var sessions = {};
    function mc(){
        this.add = function(aSessionId, aOnMessage){
            sessions[aSessionId] = aOnMessage;
        };
        this.remove = function(aSessionId){
            delete sessions[aSessionId];
        };
        this.broadcast = function(aData){
            for(var s in sessions){
                sessions[s](aData);
            }
        };
    }
    return mc;
});
-------------------------------

The server WebSocket endpoint may be implemented as:

[source,Javascript]
-------------------------------
/**
 * @public
 * @stateless
 */
define('ChatEndpoint', ['rpc'], function (Lpc) {
    function mc() {
        var accounter = new Lpc.Proxy('WebSocket/ChatAccounter');

        this.onopen = function (session) {
            // The second parameter actually is onSuccess callback of Platypus.js Lpc mechanism.
            accounter.add(session.id, function(aData){
                session.send(aData);
            });
        };
        this.onclose = function (evt) {
            // evt.id - Session id
            // evt.wasClean - True if session was closed without an error
            // evt.code - Session close code
            // evt.reason - Description of session close reason
            accounter.remove(evt.id);
        };
        this.onmessage = function (evt) {
            // evt.id - Session id
            // evt.data - Text data recieved from other (client) endpoint
            accounter.broadcast(evt.data);
        };
        this.onerror = function (evt) {
            // evt.id - Session id
            // evt.message - Error message from container's exception
        };
    }
    return mc;
});
-------------------------------

The following example shows browser client for 'ChatEndpoint' WebSocket server module.

[source,Javascript]
-------------------------------
define(['logger'], function(Logger){
    function mc(){
        var wsProtocol = "ws:";
        if (window.location.protocol == 'https:')
            wsProtocol = "wss:";

        var webSocket = new WebSocket(wsProtocol + "//" + window.location.host + window.location.pathname.substr(0, window.location.pathname.lastIndexOf("/")) + "/ChatEndpoint");
        
        webSocket.onopen = function () {
            Logger.info("onOpen");
        };
        webSocket.onerror = function () {
            Logger.info("onError");
        };
        webSocket.onmessage = function (evt) {
            Logger.info("onMessage");
        };
        webSocket.onclose = function () {
            Logger.info("onClose");
        };
    }
    return mc;
});
-------------------------------

-------------------------------------------------------------------------------------------
*Note*

Unfortunately, only one word WebSocket modules names are allowed. E.g. WebSocket endpoint module name 'SampleEndpoint' is allowed,
but 'Websocket/SampleEndpoint' is not.
-------------------------------------------------------------------------------------------

== REST services in platypus.js applications
[[restservices]]

Platypus.js applications can handle REST requests via HTTP. Regular server modules can be used as REST endpoints.
REST endpoint server modules are subject of security checks as well as other server modules. To handle a HTTP request by Platypus.js application module,
just add one of the following annotations: @get /path-paratmeter, @post /path-paratmeter, @put /path-paratmeter, @delete /path-paratmeter
to one of server module function properties, according to wich HTTP method is under consideration.

Example REST service may be implemented with Platypus.js as follows:

[source,Javascript]
-------------------------------
/**
 * @public 
 */
define('PetsSource', ['logger'], function (Logger, ModuleName) {

    var pets = [
        {name: 'Pick', from: new Date(), to: null, paid: true},
        {name: 'Tom', from: new Date(), to: null, paid: true},
        {name: 'Vaska', from: new Date(), to: null, paid: true},
        {name: 'Pushok', from: new Date(), to: null, paid: true},
        {name: 'Snezhok', from: new Date(), to: null, paid: true},
        {name: 'Murka', from: new Date(), to: null, paid: true},
        {name: 'Zorka', from: new Date(), to: null, paid: true}
    ];

    function RestAcceptor() {
        var self = this;

        /**
         * @get /pets
         */
        this.pets = function () {
            return pets;
        };
        
        /**
         * @delete /pets
         */
        this.remove = function (aPetName) {
            for (var i = 0; i < pets.length; i++) {
                if (pets[i].name === aPetName) {
                    return pets.splice(i, 1);
                }
            }
            return pets;
        };
    }
    return RestAcceptor;
});
-------------------------------

In this example /pets URI part is used, but actual HTTP request can have an URI that is much longer, for example /pets/Tom and so on.
The tail of te request's URI is passed as a first argument to handler function.
And only after this argument, onSuccess and onFailure calback are passed to handler function.

-------------------------------------------------------------------------------------------
*Note*

Note, that each HTTP request must be hanled by Platypus.js servlet at lower level to reach JavaScript modules of Platypus.js application.
So, requests' urls have to be prefixed with '/context-path/application/' to be processed by Platypus.js application modules.
-------------------------------------------------------------------------------------------

== Logging
[[logging]]

The logging subsystem is built on the base of the Java Logging
infrastructure.

To write into the log, use the `logger` module, which is a facade for the
java.util.logging.Logger class. The `Logger` object is also available in
the HTML5 web browser client.

Example of using the `Logger` object:

[source,Javascript]
------------------------------- 
require('logger', function(Logger){
    Logger.info("info text");
    Logger.warning("warning text");
    Logger.severe("severe error");
});
-------------------------------

Check the Administration Guide and Java SE documentation for information
about configuring logging subsystem.

== Filesystem I/O
[[filesystem-io]]

To read and write files, use Java API from the `java.io.*` and other
dedicated packages.

To read and write strings, use `read(path, encoding)`, and `write(path, text, encoding)`
functions from module `files`, where `path` is a path to the file, `text` is a
string, `encoding` is the name of encoding. The `encoding` parameter in
both functions is optional and by default is set for the utf-8 encoding.

Example of using functions for reading and writing strings to a file:

[source,Javascript]
-------------------------------------------------------
require('files', function(File){
    //Read from one text file and write to another
    var str = File.read('/home/user1/Documents/doc1.txt');
    File.write('/home/user1/Documents/doc2.txt', str);
});
-------------------------------------------------------

== Miscellaneous
[[miscellaneous-api]]

There are some useful functions for executing JavaScript code in unusual manner.
Some JavaScript call might be enqueued for later execution via
the `invoke` module and its `later(callback)` function.

Example of using `later(callback)` function to avoid unnecessary work on a couple of the similar events:

[source,JavaScript]
-----------
require(['invoke', 'logger'], function(Invoke, Logger){
    var processed = false;
    for(var i = 0; i < similarEvents.length; i++){
        Invoke.later(function(){
            if(!processed){
                // Some processing logic
                processed = true;
                Logger.info('All events have been processed');
            }
        });
    }
});
-----------

Also, some JavaScript code execution might be delayed for a particular timeout via
the `delayed(timeout, callback)` function of the same module.

Example of using `delayed(timeout, callback)` function to implement a periodic task:

[source,JavaScript]
-----------
require(['invoke'], function(Invoke){
    function doWork(){
        //...
        // Some work
        //...
        // Rescheduling the task...
        Invoke.delayed(100, doWork);
    }
    doWork();// First time execution of the periodic task
});
-----------
